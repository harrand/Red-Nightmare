shader(type = fragment);

import <math>
import "light"

output(id = 0) vec4 frag_colour;

struct PointLight
{
	vec2 position;
	vec3 colour;
	float power;
};

resource(id = 0) const buffer GlobalEffectBuffer
{
	uint time;
	vec2 monitor_dimensions;
	vec2 window_dimensions;
} gdata;

resource(id = 1) const buffer LightLayerImplData
{
	vec2 level_dimensions;
} impl;

resource(id = 2) const buffer LightBuffer
{
	PointLight point_lights[max_light_count];
} light;

// Phong Shading
float diffuse(vec2 vpos, PointLight l)
{
	vec2 lightDir = l.position - vpos;
	float distance = length(lightDir);
	lightDir = normalize(lightDir);

	// Calculate the diffuse lighting component using the Phong diffuse lighting model
	float diffuse = max(dot(lightDir, lightDir), 0.0);
	diffuse = l.power * diffuse / tz::math::pow(distance, 2.0f);
	return diffuse;
}

void main()
{
	vec2 vpos = in::fragment_coord.xy;
	// Image dimensions are MxM, where M is the average of the monitor width and height.
	float monmean = (gdata.monitor_dimensions.x + gdata.monitor_dimensions.y) / 2.0f;
	vpos /= (monmean * 2.0f);
	vpos.y = 1.0 - vpos.y;
	vpos *= impl.level_dimensions;
	

	vec3 col = vec3(0.0);
	for(uint i = 0; i < max_light_count; i++)
	{
		PointLight l = light.point_lights[i];
		col += l.colour * diffuse(vpos, l);
		//tz::debug::printf("lpos: %v2f, vpos: %v2f", l.position, vpos);
	}

	const vec3 norm = vec3(0.2126, 0.7152, 0.0722);
	const float threshold = 0.5;
	if(dot(col, norm) < threshold)
	{
		frag_colour = vec4(0.0f);
	}
	else
	{
		const vec2 spos = in::fragment_coord.xy;
		// Dither the output color using the 4x4 matrix of indices
		const int indexMatrix8x8[64] = int[](0, 32,  8, 40,  2, 34, 10, 42,
											48, 16, 56, 24, 50, 18, 58, 26,
											12, 44,  4, 36, 14, 46,  6, 38,
											60, 28, 52, 20, 62, 30, 54, 22,
											 3, 35, 11, 43,  1, 33,  9, 41,
											51, 19, 59, 27, 49, 17, 57, 25,
											15, 47,  7, 39, 13, 45,  5, 37,
											63, 31, 55, 23, 61, 29, 53, 21);
		int index = indexMatrix8x8[int(mod(spos.x, 8.0)) + int(mod(spos.y, 8.0)) * 8];
		float ditherThreshold = float(index) / 63.0;
		const float dither_scale = 8.0f;
		ditherThreshold *= dither_scale;
		if (min(dot(col, norm), length(threshold) + 4.0f) < threshold + ditherThreshold)
		{
			frag_colour = vec4(0.0);
		}
		else
		{
			frag_colour = vec4(col, 1.0f);
			//tz::debug::printf("light pixel at %v2f", vpos);
		}
	}
}

shader(type = vertex);

import "statuseffect"
import <debug>

vec3 status_effect_colours[StatusEffect_Count] = vec3[](
	vec3(0.5f, 0.5f, 0.5f),
	vec3(0.3f, 0.3f, 1.0f),
	vec3(0.3f, 1.0f, 0.3f),
	vec3(1.0f, 0.3f, 0.3f)
);

vec2 quad_positions[6] = vec2[](
	vec2(-1.0, -1.0), vec2(1.0, 1.0), vec2(1.0, -1.0),
	vec2(-1.0, -1.0), vec2(-1.0, 1.0), vec2(1.0, 1.0)
);

vec2 quad_texcoords[6] = vec2[](
	vec2(0.0, 1.0), vec2(1.0, 0.0), vec2(1.0, 1.0),
	vec2(0.0, 1.0), vec2(0.0, 0.0), vec2(1.0, 0.0)
);

struct ElementData
{
	vec2 position;
	vec2 scale;
	uint texture_id;
	uint normal_map_id;
	uint status_effect_id;
	float layer;
	vec2 texcoord_scale;
};

resource(id = 0) const buffer ElementBuffer
{
	ElementData data[];
} element;

struct RenderData
{
	mat4 view;
	mat4 projection;
	float ambient_lighting;
};

resource(id = 1) const buffer RenderDataBuffer
{
	RenderData data;
} render;

output(id = 0) uint out_texture_id;
output(id = 1) uint out_normal_map_id;
output(id = 2) vec2 out_texcoord;
output(id = 3) vec3 out_colour_offset;
output(id = 4) vec2 out_position;

void main()
{
	const uint quad_id = in::vertex_id / 6;
	ElementData elem = element.data[quad_id];

	out_position = elem.position + quad_positions[in::vertex_id % 6] * elem.scale;
	out::position = render.data.projection * render.data.view * vec4(out_position, -elem.layer, 1.0);
	out_texture_id = elem.texture_id;
	out_normal_map_id = elem.normal_map_id;
	out_texcoord = quad_texcoords[in::vertex_id % 6] * elem.texcoord_scale;
	out_colour_offset = status_effect_colours[elem.status_effect_id];
}

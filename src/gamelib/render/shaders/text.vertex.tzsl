shader(type = vertex);

import <math>

vec2 quad_positions[6] = vec2[](
	vec2(-1.0, -1.0), vec2(1.0, 1.0), vec2(1.0, -1.0),
	vec2(-1.0, -1.0), vec2(-1.0, 1.0), vec2(1.0, 1.0)
);

vec2 quad_texcoords[6] = vec2[](
	vec2(0.0, 1.0), vec2(1.0, 0.0), vec2(1.0, 1.0),
	vec2(0.0, 1.0), vec2(0.0, 0.0), vec2(1.0, 0.0)
);

struct word_data
{
	vec2 pos;
	vec2 scale;
	uint char_cursor;
	uint strlen;
};

// todo: no magic number.
const uint max_word_count = 128;
resource(id = 0) const buffer word_buffer
{
	word_data words[max_word_count];
};

resource(id = 1) const buffer string_buffer
{
	uint string[];
};

struct glyph_data
{
	vec2 min;
	vec2 max;
	float to_next;
};

resource(id = 2) const buffer glyph_buffer
{
	glyph_data glyphs[];
};

struct render_data
{
	mat4 view;
	mat4 projection;
};

resource(id = 3) const buffer render_data_buffer
{
	render_data render;
};

resource(id = 4) const texture images[];

output(id = 0) uint out_texture_id;
output(id = 1) vec2 out_texcoord;

uint get_texture(uint bit_position)
{
	uint data = string[bit_position / 4];
	uint encoded = data >> (bit_position * 8);
	encoded &= 0xff;

	// we get our char. need to do some processiing.
	// if its between 48-57, its a decimal number and we need to -48
	if(encoded >= 48 && encoded <= 57)
	{
		encoded -= 48;
		//tz::debug::printf("%d", encoded);
		encoded += 26 + 26;
	}
	else if(encoded >= 65 && encoded <= 90)
	{
		encoded -= 65;
		//tz::debug::printf("%dth upr", encoded);
		encoded += 26;
	}
	else if(encoded >= 97 && encoded <= 122)
	{
		encoded -= 97;
		//tz::debug::printf("%dth lwr", encoded);
	}
	else
	{
		return 0;
	}
	return encoded + 1;
}

import <debug>

void main()
{
	// one quad per char.
	const uint quad_id = in::vertex_id / 6;
	// 4 bytes per uint. we want to reintepret string[] and find the nth byte, where n is quad_id.
	out_texture_id = get_texture(quad_id);
	out_texcoord = quad_texcoords[in::vertex_id % 6];
	// figure out what word buffer we need.
	word_data wdata = words[0];
	for(int i = 1; i < max_word_count; i++)
	{
		if(words[i].char_cursor > quad_id || words[i].char_cursor == uint(-1))
		{
			//tz::debug::printf("broke at %d", i);
			break;
		}
		wdata = words[i];
	}
	if(wdata.char_cursor + wdata.strlen <= quad_id)
	{
		// assume 0 == invisible.
		out_texture_id = 0;
	}

	uint word_index = quad_id - wdata.char_cursor;
	vec2 scale = wdata.scale;
	//scale *= (glyphs[out_texture_id].max - glyphs[out_texture_id].min);
	ivec2 texdims = textureSize(images[out_texture_id], 0);
	//scale.x *= (float(texdims.x) / texdims.y);
	scale *= tz::math::normalise(texdims);
	vec4 worldspace_pos = vec4(wdata.pos + (quad_positions[in::vertex_id % 6] * scale), 0.0f, 1.0f);
	worldspace_pos.x += float(word_index) * (wdata.scale.x * 1.5f);
	out::position = (render.projection * render.view) * worldspace_pos;
}

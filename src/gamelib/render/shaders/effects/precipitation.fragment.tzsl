shader(type = fragment);

import <noise>
import <math>

output(id = 0) vec4 frag_colour;

resource(id = 0) const buffer GlobalEffectBuffer
{
	uint time;
} gdata;

resource(id = 1) const buffer RainBuffer
{
	float speed;
	float density;
	float scale;
	vec2 direction;
	float layer_strength;
	uint noise_layer_count;
	vec3 colour;
	vec3 rand_colour_tint;
} rain;

float get_rain(vec2 uv)
{
	float rand = tz::noise::simplex(uv / rain.scale);
	return tz::noise::simplex(uv + vec2(rand, 0.0));
}

void main()
{
	vec2 real_rain_dir = vec2(-rain.direction.x, rain.direction.y);

	vec2 uv = in::fragment_coord.xy + real_rain_dir * gdata.time * rain.speed;
	uv *= rain.scale;

	float alpha = 0.0f;
	alpha += get_rain(uv);
	// Add another layer of noise so its a bit more, er, noisey.
	for(uint i = 0; i < rain.noise_layer_count; i++)
	{
		float n = float(rain.noise_layer_count) * rain.layer_strength;
		alpha += get_rain(uv * float(rain.noise_layer_count) * n) * n;
	}
	vec3 random_colour_increase = rain.rand_colour_tint * get_rain(uv * 12.0f);
	random_colour_increase.y *= get_rain(uv.yy * 123.0f);
	random_colour_increase.z *= get_rain(uv.yx * 123456.0f);
	frag_colour = vec4(rain.colour + random_colour_increase, alpha * rain.density);
}

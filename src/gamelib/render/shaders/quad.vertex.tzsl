shader(type = vertex);

import <math>
import <debug>

struct quad_data
{
	vec2 pos;
	vec2 scale;
	vec3 colour_tint;
	float rotation;
	uint texid;
	int layer;
};

struct render_data
{
	mat4 view;
	mat4 projection;
	bool debug_depth_view;
	bool debug_colour_view;
};

vec2 quad_positions[6] = vec2[](
	vec2(-1.0, -1.0), vec2(1.0, 1.0), vec2(1.0, -1.0),
	vec2(-1.0, -1.0), vec2(-1.0, 1.0), vec2(1.0, 1.0)
);

vec2 quad_texcoords[6] = vec2[](
	vec2(0.0, 1.0), vec2(1.0, 0.0), vec2(1.0, 1.0),
	vec2(0.0, 1.0), vec2(0.0, 0.0), vec2(1.0, 0.0)
);

resource(id = 0) const buffer quad_data_buffer
{
	quad_data data[];
} quads;

resource(id = 1) const buffer render_data_buffer
{
	render_data render;
};

output(id = 0) uint out_texid;
output(id = 1) float out_depth;
output(id = 2) vec2 out_texcoord;
output(id = 3) vec3 out_colour_tint;

void main()
{
	const uint quad_id = in::vertex_id / 6;
	quad_data q = quads.data[quad_id];
	mat2 rotation_matrix = mat2(cos(q.rotation), -sin(q.rotation), sin(q.rotation), cos(q.rotation));
	vec4 worldspace_pos = vec4(q.pos + (rotation_matrix * quad_positions[in::vertex_id % 6] * q.scale), 0.0f, 1.0f);
	out::position = (render.projection * render.view) * worldspace_pos;
	out_texid = q.texid;

	// depth handling.
	// q.layer should always be between 0.0 and 1000.0.
	// unlike traditional depth, higher means closer. this might want to be changed, but that's the way it was in rn2 and how it is now.
	const float max_y_coord = 1000.0f;
	out_depth = (q.layer / max_y_coord) * 0.5f;
	// out_depth should ultimately be between 0.0f-1.0f to work for both opengl and vulkan.
	// as we take q.layer into account, the layer accounts for half the value, and the y-coordinate for the other half. hence why we multiply by 0.5 here.
	// this means that:
	// q.layer must be between 0 and 500 to be valid.
	// q.pos.y must be between -1000 and 1000 to be valid.
	out_depth += ((max_y_coord + q.pos.y) * 0.5f / max_y_coord) * 0.5f;
	
	out_texcoord = quad_texcoords[in::vertex_id % 6];
	out_colour_tint = q.colour_tint;

#if TZ_DEBUG
	if(q.pos.y > max_y_coord || q.pos.y < -max_y_coord)
	{
		tz::debug::printf("Found a quad (vid: %u) that has an invalid position. q.pos.y == %.3f, max_y_coord = %.3f", quad_id, q.pos.y, max_y_coord);
		tz::debug::assert(false);		
	}
	tz::debug::assert(out_depth >= 0.0f && out_depth <= 1.0f);
#endif
}

shader(type = fragment);
#define MAX_TEX_COUNT 8
#define BADU ~0u

struct texture_locator
{
	vec3 colour_tint;
	uint texture_id;
	float texture_scale;
};

output(id = 0) vec4 out::colour;
output(id = 1) vec4 out::pixelated_colour;
input(id = 0) vec2 in::texcoord;
input(id = 1) vec3 in::normal;
input(id = 2) vec3 in::colour;
input(id = 3, flat) uvec2 in::joint_suffix;
input(id = 4, flat) texture_locator in::textures[MAX_TEX_COUNT];
resource(id = 4) const texture res::textures[];

void main()
{
	vec4 outcol = vec4(vec3(0.0f), 1.0f);
	//out::colour = vec4(vec3(0.0f), 1.0f);
	//bool any_texture_applied = false;
	bool should_pixelate = bool(in::joint_suffix.x);

	// TODO: use correct texcoords. we have the data, it should be stored in texture-locator maybe? for now we always use texcoord 0 which is wrong.
	// we have MAX_TEX_COUNT slots.
	// some of these are dedicated for a fixed purpose.
	// namely: 0 is base colour, 1 is metallic roughness, ...

	texture_locator base_colour = in::textures[0];
	if(base_colour.texture_id == BADU)
	{
		// use solid red.
		outcol = vec4(1.0f, 1.0f, 1.0f, 1.0f);
	}
	else
	{
		// note: base colour is guaranteed to be sRGB. we need to tonemap here ideally, but we don't right now.
		// note2: we discard fragments with alpha values lower than 0.1.
		// this is not a documented feature, and should be disabled by default. TODO: less shit
		vec4 col = texture(res::textures[base_colour.texture_id], in::texcoord * base_colour.texture_scale);
		if(col.w < 0.1f)
		{
			discard;
			return;
		}
		outcol.xyz = col.xyz * base_colour.colour_tint;
	}
	texture_locator metallic_roughness = in::textures[1];
	if(metallic_roughness.texture_id != BADU)
	{
		// green contains roughness values, blue contains metalness values.
		vec3 mrsample = texture(res::textures[metallic_roughness.texture_id], in::texcoord * metallic_roughness.texture_scale).xyz * metallic_roughness.colour_tint;
		float roughness = mrsample.g;
		float metallicness = mrsample.b;
		// TODO: pbr magic!
	}
	outcol.xyz *= in::colour;

	if(should_pixelate)
	{
		// make our depth really really close to 0.
		// if we assume in::fragment_coord.z is between 0 and 1, we make our depth between 0.999-1.0, but still preserving depth order.
		// this means that the fragment we write into the unpixelated colour is almost *certainly* gonna be overwritten by something else.
		// however, the pixelated buffer will *only* contain fragments with this depth operation applied, so the depth test is preserved (if way less accurate. we're a 2d game, who cares???)
		out::fragment_depth = 0.999f + (in::fragment_coord.z / 1000.0f);
		out::colour = vec4(0.0);
		out::pixelated_colour = outcol;
	}
	else
	{
		// stupid rule if any path writes to depth, all must do.
		// just write what the depth was gonna be anyway.
		out::fragment_depth = in::fragment_coord.z;
		out::colour = outcol;
		out::pixelated_colour = vec4(0.0);
	}

	//for(uint i = 0; i < MAX_TEX_COUNT; i++)
	//{
	//	if(in::textures[i].texture_id == BADU)
	//	{
	//		continue;
	//	}
	//	texture_locator tex = in::textures[i];
	//	out::colour.xyz += texture(res::textures[tex.texture_id], in::texcoord).xyz * tex.colour_tint;
	//	any_texture_applied = true;
	//}
	//if(!any_texture_applied)
	//{
	//	out::colour = vec4(1.0f, 0.0f, 0.0f, 1.0f);
	//}
}

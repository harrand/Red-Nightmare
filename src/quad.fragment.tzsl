shader(type = fragment);

input(id = 0, flat) uint in_texture_id;
input(id = 1, flat) uint in_normal_map_id;
input(id = 2) vec2 in_texcoord;
input(id = 3) vec3 colour_offset;
input(id = 4) vec2 position;
input(id = 5, flat) uint autolayer;
output(id = 0) vec4 frag_colour;

import <math>
import "effects/light"

struct RenderData
{
	mat4 view;
	mat4 projection;
	float ambient_lighting;
};

resource(id = 1) const buffer RenderDataBuffer
{
	RenderData data;
} render;

struct PointLight
{
	vec2 position;
	vec3 colour;
	float power;
};

resource(id = 2) const buffer LightBuffer
{
	PointLight point_lights[max_light_count];
} light;

resource(id = 3) const texture images[];

// Phong Shading
float diffuse(PointLight l, vec3 normal)
{
	vec2 lightDir = l.position - position;
	float distance = length(lightDir);
	lightDir = normalize(lightDir);

	// Calculate the diffuse lighting component using the Phong diffuse lighting model
	float diffuse = max(dot(vec3(0.0f, 0.0f, 1.0f), normal), 0.0);
	diffuse = l.power * 0.5f * diffuse / tz::math::pow(distance, 2.0f);
	return diffuse;
}

float specular(PointLight l, vec3 normal)
{
	const vec3 view_dir = vec3(0.0f, 0.0f, 1.0f);
	vec2 light_dir = l.position - position;
	float distance = length(light_dir);
	light_dir = normalize(light_dir);

	float specular = pow(max(dot(normal, vec3(0.0f, 0.0f, 1.0f)), 0.0), 8);
	specular = l.power * specular / tz::math::pow(distance, 2.0f);
	return specular;
}

void main()
{
	out::fragment_depth = float(autolayer) / 10000.0f;
	frag_colour = texture(images[in_texture_id], in_texcoord);
	vec3 normal = (255.0f/128.0f * texture(images[in_normal_map_id], in_texcoord).rgb) - 1;
	frag_colour.r = tz::math::min(frag_colour.r, colour_offset.r * 2.0f);
	frag_colour.g = tz::math::min(frag_colour.g, colour_offset.g * 2.0f);
	frag_colour.b = tz::math::min(frag_colour.b, colour_offset.b * 2.0f);
	frag_colour.xyz += (colour_offset - vec3(0.5f));
	frag_colour.xyz *= render.data.ambient_lighting;
	if(frag_colour.a < 0.9f)
	{
		discard;
	}
	for(uint i = 0; i < max_light_count; i++)
	{
		frag_colour += vec4(light.point_lights[i].colour * diffuse(light.point_lights[i], normal) * specular(light.point_lights[i], normal), 0.0f);
	}
	//frag_colour = vec4(vec3(out::fragment_depth), 1.0f);
}

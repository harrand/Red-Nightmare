shader(type = fragment);

input(id = 0, flat) uint in_texture_id;
input(id = 1) vec2 in_texcoord;
input(id = 2) vec3 colour_offset;
input(id = 3) vec2 position;
output(id = 0) vec4 frag_colour;

import <math>

struct RenderData
{
	mat4 view;
	mat4 projection;
	float ambient_lighting;
};

resource(id = 1) const buffer RenderDataBuffer
{
	RenderData data;
} render;

struct PointLight
{
	vec2 position;
	vec3 colour;
	float power;
};

const uint light_count = 64;
resource(id = 2) const buffer LightBuffer
{
	PointLight point_lights[light_count];
} light;

resource(id = 3) const texture images[];

// Phong Shading
float diffuse(PointLight l)
{
	vec2 lightDir = l.position - position;
	float distance = length(lightDir);
	lightDir = normalize(lightDir);

	// Calculate the diffuse lighting component using the Phong diffuse lighting model
	float diffuse = max(dot(lightDir, lightDir), 0.0);
	diffuse = l.power * 0.5f * diffuse / tz::math::pow(distance, 2.0f);
	return diffuse;
}

void main()
{
	frag_colour = texture(images[in_texture_id], in_texcoord);
	frag_colour.r = tz::math::min(frag_colour.r, colour_offset.r * 2.0f);
	frag_colour.g = tz::math::min(frag_colour.g, colour_offset.g * 2.0f);
	frag_colour.b = tz::math::min(frag_colour.b, colour_offset.b * 2.0f);
	frag_colour.xyz += (colour_offset - vec3(0.5f));
	frag_colour.xyz *= render.data.ambient_lighting;
	if(frag_colour.a < 0.9f)
	{
		discard;
	}
	for(uint i = 0; i < light_count; i++)
	{
		frag_colour += vec4(light.point_lights[i].colour * diffuse(light.point_lights[i]), 0.0f);
	}
}
